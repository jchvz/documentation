---
title: algo
description: Set of procedures for graph algorithms, enabling advanced graph analysis and path finding.
---

import { Callout } from 'nextra/components'
import { Card, Cards } from 'nextra/components'
import GitHub from '/components/icons/GitHub'

# algo

The algo module provides users with a powerful set of graph algorithms,
enabling users to perform complex graph-based operations and computations, such as graph traversal, edge detection, and more.

<Cards>
  <Card
    icon={<GitHub />}
    title="Source code"
    href="https://github.com/memgraph/mage/tree/main/cpp/algo_module"
  />
</Cards>

| Trait               | Value               |
| ------------------- | ------------------- |
| **Module type**     | algorithm           |
| **Implementation**  | C++                 |
| **Graph direction** | directed/undirected |
| **Edge weights**    | weighted/unweighted |
| **Parallelism**     | sequential          |

## Procedures

<Callout type="info">
You can execute this algorithm on [graph projections, subgraphs or portions of the graph](/advanced-algorithms/run-algorithms#run-procedures-on-subgraph).
</Callout>

### `all_simple_paths()`

Return every simple path (one which does not visit the same node twice) from `start_node` to `end_node` satisfying the given relationship filters.

{<h4> Input: </h4>}

- `start_node: Node` ➡ First node of the returned path.
- `end_node: Node` ➡ Final node of the returned path.
- `relationship_types: List[String]` ➡ A list of relationship filters, explained below.
- `max_length: int` ➡ Max path length.

{<h4> Output: </h4>}

- `path: Path` ➡ A path which satisfies the given conditions.

#### Relationship filters:

Relationship filters are described in the table below:

| Option             | Explanation                                                                                                 |
|--------------------|-------------------------------------------------------------------------------------------------------------|
| `TYPE`             | Path will expand with either outgoing or incoming relationships of this type.                               |
| `<TYPE`            | Path will expand with incoming relationships of this type.                                                  |
| `TYPE>`            | Path will expand with outgoing relationships of this type.                                                  |
| `<TYPE>`           | Path will expand if both incoming and outgoing relationship of this type exists between the same two nodes. |
| `>`                | Path will expand with all outgoing relationships.                                                           |
| `<`                | Path will expand will all incoming relationships.                                                           |

{<h4> Usage: </h4>}

Graph creation:

```cypher
CREATE (n1:Node1), (n2:Node2), (n3:Node3), (n4:Node4), (n5:Node5), (n6:Node6) CREATE (n1)-[r1:CONNECTED]->(n2), (n2)-[r2:CONNECTED]->(n3), (n3)-[r3:CONNECTED]->(n4), (n4)-[r4:CONNECTED]->(n5), (n5)-[r5:CONNECTED]->(n6), (n1)-[r6:CONNECTED]->(n3), (n4)-[r7:CONNECTED]->(n6), (n2)-[r8:CONNECTED]->(n1), (n3)-[r9:CONNECTED]->(n2);
```
![](/pages/advanced-algorithms/available-algorithms/algo/simplepaths_graph.png)

Query which returns all simple paths of maximum length 2 between Node1 and Node3:

```cypher
MATCH (n:Node1) MATCH (m:Node3)
CALL algo.all_simple_paths(n, m, [], 2) YIELD path AS result RETURN result;
```

Results:

The procedure will return 4 paths of length 2 and 1 path of length 1 as follows:
```plaintext
{"nodes":[{"id":18,"labels":["Node1"],"properties":{},"type":"node"},{"id":19,"labels":["Node2"],"properties":{},"type":"node"},{"id":20,"labels":["Node3"],"properties":{},"type":"node"}],"relationships":[{"id":32,"start":19,"end":18,"label":"CONNECTED","properties":{},"type":"relationship"},{"id":33,"start":20,"end":19,"label":"CONNECTED","properties":{},"type":"relationship"}],"type":"path"},
{"nodes":[{"id":18,"labels":["Node1"],"properties":{},"type":"node"},{"id":19,"labels":["Node2"],"properties":{},"type":"node"},{"id":20,"labels":["Node3"],"properties":{},"type":"node"}],"relationships":[{"id":32,"start":19,"end":18,"label":"CONNECTED","properties":{},"type":"relationship"},{"id":26,"start":19,"end":20,"label":"CONNECTED","properties":{},"type":"relationship"}],"type":"path"},
{"nodes":[{"id":18,"labels":["Node1"],"properties":{},"type":"node"},{"id":19,"labels":["Node2"],"properties":{},"type":"node"},{"id":20,"labels":["Node3"],"properties":{},"type":"node"}],"relationships":[{"id":25,"start":18,"end":19,"label":"CONNECTED","properties":{},"type":"relationship"},{"id":33,"start":20,"end":19,"label":"CONNECTED","properties":{},"type":"relationship"}],"type":"path"},
{"nodes":[{"id":18,"labels":["Node1"],"properties":{},"type":"node"},{"id":19,"labels":["Node2"],"properties":{},"type":"node"},{"id":20,"labels":["Node3"],"properties":{},"type":"node"}],"relationships":[{"id":25,"start":18,"end":19,"label":"CONNECTED","properties":{},"type":"relationship"},{"id":26,"start":19,"end":20,"label":"CONNECTED","properties":{},"type":"relationship"}],"type":"path"},
{"nodes":[{"id":18,"labels":["Node1"],"properties":{},"type":"node"},{"id":20,"labels":["Node3"],"properties":{},"type":"node"}],"relationships":[{"id":30,"start":18,"end":20,"label":"CONNECTED","properties":{},"type":"relationship"}],"type":"path"}
```

### `cover()`

Returns relationships between every two nodes in the list, including self relationship.

{<h4> Input: </h4>}

- `nodes: List[Node]` ➡ A list of all the input nodes.

{<h4> Output: </h4>}

- `rel: Relationship` ➡ for each relationship between nodes, a separate record is created, and a relationship is returned.

{<h4> Usage: </h4>}

Graph creation:

```cypher
CREATE (d:Dog)-[s:SELF_REL]->(d), (d)-[l:LOVES]->(h:Human), (h)-[li:LIVES_IN]->(ho:House);
```
![](/pages/advanced-algorithms/available-algorithms/algo/cover_graph.png)

```cypher
MATCH (d:Dog),(ho:House),(h:Human)
CALL algo.cover([d, ho, h]) YIELD rel
RETURN startNode(rel), rel, endNode(rel);
```
Result:

![](/pages/advanced-algorithms/available-algorithms/algo/cover_result.png)

As we can see from the result, `algo.cover` returned relationships between each two nodes in the input list, including self relationships.


### `astar()`

Runs the A * search algorithm between the start and target node.
Supports either `Numeric` or `Duration` data types for distance and heuristic properties.
Additionally, the algorithm can be run with multiple configs, described below in the `Configuration` section.

{<h4> Input: </h4>}

- `start: Node` ➡ the starting node of the algorithm.
- `target: Node` ➡ the target node of the algorithm.
- `config: Map` ➡ configuration map for the algorithm.

{<h4> Output: </h4>}

- `path: Path` ➡ the resulting shortest path calculated by the algorithm.
- `weight: float` ➡ weight of the shortest path.

{<h4> Default heuristic: </h4>}

In this section, the default heuristic is explained. The default heuristic works with the assumption that the
nodes in the graph represent geospatial points and that they have defined properties for latitude and longitude.
In that case, the heuristic for each node is [haversine distance](https://en.wikipedia.org/wiki/Haversine_formula)
between the current node and the target node on Earth, and is returned in kilometres. In case you don't want to use geospatial types,
or you want a custom heuristic, check the `Configuration` section below.

{<h4> Configuration: </h4>}

Listed here are all configurations. To enable the configuration, when passing `config` in function arguments,
set the configuration to a desired value. `Example: CALL algo.astar(startNode,targetNode, {configuration_name: configuration_value})`.
Without some configs, the algorithm can't be run, so they have a default value.

- `distance_prop: string, default = distance` - the name of the distance property in relationships, which is used in calculations. If unspecified,
the default is used.
- `latitude_name: string, default = lat` - the name of the latitude property in nodes, which is needed for heuristic calculation. If unspecified,
the default is used.
- `longitude_name: string, default = lon` - the name of the longitude property in nodes, which is needed for heuristic calculation. If unspecified,
the default is used.
- `heuristic_name: string` - the name of the custom heuristic property. For example, if you don't want to use the provided heuristic,
you can always define a custom heuristic property in your nodes, and use that. If this option is specified, even if the nodes are geospatial,
the default heuristic is ignored.
- `whitelisted_labels: List[string]` - a list of whitelisted labels. If this list is not empty, the algorithm will search for the path only through the node
with specified labels. Example: `whitelisted_labels: ["City", "Village"]` means only nodes labelled `City` or `Village` will be considered.
- `blacklisted_labels: List[string]` - a list of blacklisted labels. If this list is not empty, the algorithm will not search for the path through nodes with
specified labels. Example: `blacklisted_labels: ["City", "Village"]` means nodes labelled `City` or `Village` will NOT be considered.
- `relationships_filter: List[string]` - a list used for filtering relationships. If the list is empty, the algorithm will search the path
through all possible relationships. If the list isn't empty, the algorithm will only search the path through the provided relationships.
There are three possible ways to define a relationship inside the filter. Firstly: `<REL_NAME>`, means only incoming relationships with the
provided name will be considered by the algorithm. `REL_NAME>` means only outgoing relationships with the provided name will be considered
by the algorithm. Lastly, `REL_NAME` means that bout outgoing and incoming relationships with the provided name will be considered
by the algorithm.
- `duration: bool, default = false` - if `true`, means that the distance and heuristic are of a `Duration` data type. NOTE: If they are not created
as a `Duration` data type, and the `duration` config is specified as `true`, an exception is thrown. Also, if this config is `true`, the `weight`
output will be returned as `int`, representing the duration in microseconds.
- `unweighted: bool, default = false` - if `true`, the algorithm will run unweighted, using only heuristics, not distances between nodes.
This config will still return the path weight, but it will count each distance the same, as 10.
- `epsilon: double, default = 1.0` - if the user has provided an admissible heuristic, or if they use the default heuristic,
they can choose to use the Bounded relaxation property of A *, and multiply the heuristic by `epsilon` value. This will result in a faster algorithm, with a solution
at most `epsilon` times worse than the base algorithm. See [more](https://en.wikipedia.org/wiki/A*_search_algorithm#Bounded_relaxation).



{<h4> Usage: </h4>}

{<h5> Graph creation: </h5>}


Graph will have five `City` nodes, and four `MO` nodes. Each node will have a defined latitude and longitude.
Relationships will be of types `ROAD` and `RIVER`. Each relationship has a defined distance property.

```cypher
CREATE (c1:City1 {lat: -1, lon: -1}), (c2:City2 {lat: 1, lon: -11}),
(c3:City3 {lat: 1, lon: 1}), (c4:City4 {lat: -1, lon: 1}), (c5:City5 {lat: 0, lon: 0}),
(m1:MO1 {lat: -0.5, lon: -0.5}), (m2:MO2 {lat: 0.5, lon: -0.5}),
(m3:MO3 {lat: 0.5, lon: 0.5}) ,(m4:MO4 {lat: -0.5, lon: 0.5}),
(c1)-[r1:ROAD {distance: 300}]->(c2),
(c2)-[r2:ROAD {distance: 300}]->(c3),
(c4)-[r3:ROAD {distance: 280}]->(c3),
(c4)-[r4:ROAD {distance: 310}]->(c1),
(c1)-[r5:RIVER {distance: 90}]->(m1),
(c2)-[r6:ROAD {distance: 90}]->(m2),
(c3)-[r7:ROAD {distance: 85}]->(m3),
(c4)-[r8:ROAD {distance: 100}]->(m4),
(m1)-[r9:RIVER {distance: 140}]->(m4),
(m4)-[r10:RIVER {distance: 145}]->(m3),
(m3)-[r11:RIVER {distance: 130}]->(m2),
(m2)-[r12:RIVER {distance: 125}]->(m1),
(m2)-[r13:ROAD {distance: 90}]->(c5),
(m3)-[r14:RIVER {distance: 100}]->(c5)
```
![](/pages/advanced-algorithms/available-algorithms/algo/a_star_graph.png)

{<h5> Default usage: </h5>}

Since the distance property is already named `distance`, and latitude and longitude properties are already named `lat` and `lon`,
config map is unnecessary, and the algorithm can be run without it.

```cypher
MATCH (c1:City1), (c5:City5)
CALL algo.astar(c1,c5, {}) YIELD path, weight  RETURN path, weight;
```
Result:

![](/pages/advanced-algorithms/available-algorithms/algo/astar_result1.png)

```plaintext
+----------------------------+
| weight                     |
+----------------------------+
| 305                        |
+----------------------------+
```

{<h5> Usage with relationship filtering: </h5>}

Same as base usage, the only difference being the addition of relationships_filter property. Now, only outgoing
relationships of type `RIVER` will be considered in path finding.

```cypher
MATCH (c1:City1), (c5:City5 )
CALL algo.astar(c1,c5, {relationships_filter:["RIVER>"]}) YIELD path, weight RETURN path, weight;
```

Result:

![](/pages/advanced-algorithms/available-algorithms/algo/astar_result2.png)

```plaintext
+----------------------------+
| weight                     |
+----------------------------+
| 475                        |
+----------------------------+
```

{<h5> Usage with blacklisting: </h5>}

Same as base usage, the only difference being the addition of blacklisted labels. In this case, the algorithm won't consider
nodes labelled `MO1`, `MO2`, `MO3`.

```cypher
MATCH (c1:City1), (c5:City5)
CALL algo.astar(c1,c5, {blacklisted_labels: ["MO1", "MO2","MO4"]}) YIELD path, weight RETURN path, weight;
```

Result:

![](/pages/advanced-algorithms/available-algorithms/algo/astar_result3.png)

```plaintext
+----------------------------+
| weight                     |
+----------------------------+
| 775                        |
+----------------------------+
```

{<h5> Usage with unweigthed: </h5>}

In this case, the algorithm won't consider the distance property, instead, it will treat every relationship the same, as having a distance of 10.

```cypher
MATCH (c1:City1), (c5:City5)
CALL algo.astar(c1,c5, {unweighted: true}) YIELD path, weight  RETURN path, weight;
```

Result:

![](/pages/advanced-algorithms/available-algorithms/algo/astar_result4.png)

```plaintext
+----------------------------+
| weight                     |
+----------------------------+
| 30                         |
+----------------------------+
```

{<h5> Custom latitude, longitude and distance name: </h5>}

Same as base usage, only the property names have been changed.

```cypher
CREATE
(c1:City1 {latitude: -1, longitude: -1}),
(c2:City2 {latitude: 1, longitude: -1}),
(c3:City3 {latitude: 1, longitude: 1}),
(c4:City4 {latitude: -1, longitude: 1}),
(c5:City5 {latitude: 0, longitude: 0}),
(m1:MO1 {latitude: -0.5, longitude: -0.5}),
(m2:MO2 {latitude: 0.5, longitude: -0.5}),
(m3:MO3 {latitude: 0.5, longitude: 0.5}),
(m4:MO4 {latitude: -0.5, longitude: 0.5}),
(c1)-[r1:ROAD {separation: 300}]->(c2),
(c2)-[r2:ROAD {separation: 300}]->(c3),
(c4)-[r3:ROAD {separation: 280}]->(c3),
(c4)-[r4:ROAD {separation: 310}]->(c1),
(c1)-[r5:RIVER {separation: 90}]->(m1),
(c2)-[r6:ROAD {separation: 90}]->(m2),
(c3)-[r7:ROAD {separation: 85}]->(m3),
(c4)-[r8:ROAD {separation: 100}]->(m4),
(m1)-[r9:RIVER {separation: 140}]->(m4),
(m4)-[r10:RIVER {separation: 145}]->(m3),
(m3)-[r11:RIVER {separation: 130}]->(m2),
(m2)-[r12:RIVER {separation: 125}]->(m1),
(m2)-[r13:ROAD {separation: 90}]->(c5),
(m3)-[r14:RIVER {separation: 100}]->(c5);
```

```cypher
MATCH (c1:City1 ), (c5:City5 )
CALL algo.astar(c1,c5, {distance_prop:"separation", latitude_name: "latitude", longitude_name:"longitude"}) YIELD path, weight RETURN path, weight;
```

Result:

![](/pages/advanced-algorithms/available-algorithms/algo/astar_result5.png)

```plaintext
+----------------------------+
| weight                     |
+----------------------------+
| 305                        |
+----------------------------+
```

As expected, results are the same as in base usage, since the only change was renaming.


{<h5> Usage with custom heuristic: </h5>}

In this case, the default heuristic isn't used. Instead, each node already has manually calculated haversine distance,
saved under `heur` property. Now, in the config map, a `heuristic_name` property must be included.

```cypher
CREATE (c1:City1 {heur: 157.2}), (c2:City2 {heur: 157.2}), (c3:City3 {heur: 157.2}),
(c4:City4 {heur: 157.2}),
(c5:City5 {heur: 0}),
(m1:MO1 {heur: 78.62}), (m2:MO2 {heur: 78.62}),
(m3:MO3 {heur: 78.62}) ,(m4:MO4 {heur: 78.62}),
(c1)-[r1:ROAD {distance: 300}]->(c2),
(c2)-[r2:ROAD {distance: 300}]->(c3),
(c4)-[r3:ROAD {distance: 280}]->(c3),
(c4)-[r4:ROAD {distance: 310}]->(c1),
(c1)-[r5:RIVER {distance: 90}]->(m1),
(c2)-[r6:ROAD {distance: 90}]->(m2),
(c3)-[r7:ROAD {distance: 85}]->(m3),
(c4)-[r8:ROAD {distance: 100}]->(m4),
(m1)-[r9:RIVER {distance: 140}]->(m4),
(m4)-[r10:RIVER {distance: 145}]->(m3),
(m3)-[r11:RIVER {distance: 130}]->(m2),
(m2)-[r12:RIVER {distance: 125}]->(m1),
(m2)-[r13:ROAD {distance: 90}]->(c5),
(m3)-[r14:RIVER {distance: 100}]->(c5)
```

```cypher
MATCH (c1:City1 ), (c5:City5 )
CALL algo.astar(c1,c5, {heuristic_name: "heur"}) YIELD path, weight RETURN path, weight;
```

Result:

![](/pages/advanced-algorithms/available-algorithms/algo/astar_result6.png)

```plaintext
+----------------------------+
| weight                     |
+----------------------------+
| 305                        |
+----------------------------+
```

{<h5> Usage with duration: </h5>}

In this case, the heuristic value and distance value aren't `Numeric` data types, but rather `Duration` data types.
Also, only `RIVER` relationships are allowed, both incoming and outgoing. Since a custom heuristic is used, it needs to be specified
alongside other properties.

```cypher
CREATE (c1:City1 {heur: duration("PT1H30M")}), (c2:City2 {heur: duration("PT1H30M")}), (c3:City3 {heur: duration("PT1H30M")}),
(c4:City4 {heur: duration("PT1H30M")}),
(c5:City5 {heur: duration("PT0H")}),
(m1:MO1 {heur: duration("PT47M")}), (m2:MO2 {heur: duration("PT47M")}),
(m3:MO3 {heur: duration("PT47M")}) ,(m4:MO4 {heur: duration("PT47M")}),
(c1)-[r1:ROAD {distance: duration("PT3H")}]->(c2),
(c2)-[r2:ROAD {distance: duration("PT3H")}]->(c3),
(c4)-[r3:ROAD {distance: duration("PT2H48M")}]->(c3),
(c4)-[r4:ROAD {distance: duration("PT3H6M")}]->(c1),
(c1)-[r5:RIVER {distance: duration("PT54M")}]->(m1),
(c2)-[r6:ROAD {distance: duration("PT54M")}]->(m2),
(c3)-[r7:ROAD {distance: duration("PT51M")}]->(m3),
(c4)-[r8:ROAD {distance: duration("PT1H")}]->(m4),
(m1)-[r9:RIVER {distance: duration("PT1H24M")}]->(m4),
(m4)-[r10:RIVER {distance: duration("PT1H27M")}]->(m3),
(m3)-[r11:RIVER {distance: duration("PT1H18M")}]->(m2),
(m2)-[r12:RIVER {distance: duration("PT1H15M")}]->(m1),
(m2)-[r13:ROAD {distance: duration("PT54M")}]->(c5),
(m3)-[r14:RIVER {distance: duration("PT1H")}]->(c5)

```

```cypher
MATCH (c1:City1 ), (c5:City5 )
CALL algo.astar(c1,c5, {heuristic_name: "heur", duration: true, relationships_filter: ["RIVER"]})
YIELD path, weight RETURN path, weight;
```

Result:

![](/pages/advanced-algorithms/available-algorithms/algo/astar_result7.png)

```plaintext
+----------------------------+
| weight                     |
+----------------------------+
| 16,020,000,000             |
+----------------------------+
```
